{"version":3,"file":"dispatchApiCall.js","sources":["../../src/api/errors/errors.ts","../../src/data/transforms/transform-shipping-methods.ts","../../src/signals/CartSignal.ts","../../src/signals/EstimateShippingMethodsSignal.ts","../../src/signals/RegionsSignal.ts","../../src/api/utils/enqueueRequest.ts","../../src/api/utils/filterControlledErrors.ts","../../src/api/utils/dispatchApiCall.ts"],"sourcesContent":["import { FetchQueryError } from '@adobe/fetch-graphql';\n\nexport class FetchError extends Error {\n  constructor(reasons: FetchQueryError) {\n    super(reasons.map((e: any) => e.message).join(' '));\n    this.name = 'FetchError';\n  }\n}\n\nexport class InvalidArgument extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InvalidArgument';\n  }\n}\n\nexport class UnexpectedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'UnexpectedError';\n  }\n}\n\nexport class MissingCart extends InvalidArgument {\n  constructor() {\n    super('Cart ID is required');\n  }\n}\nexport class MissingEmail extends InvalidArgument {\n  constructor() {\n    super('Email is required');\n  }\n}\n\nexport class MissingPaymentMethod extends InvalidArgument {\n  constructor() {\n    super('Payment method code is required');\n  }\n}\n\nexport class MissingBillingAddress extends InvalidArgument {\n  constructor() {\n    super('Billing address is required');\n  }\n}\n\nexport class MissingCountry extends InvalidArgument {\n  constructor() {\n    super('Country Code is required');\n  }\n}\n","import { ShippingMethod } from '@/checkout/data/models/shipping-method';\nimport { GetCheckoutDataQuery } from '@/checkout/__generated__/types';\nimport { isNullish } from '@/checkout/utils/isNullish';\n\ntype Cart = NonNullable<GetCheckoutDataQuery['cart']>;\ntype ShippingAddresses = Cart['shipping_addresses'];\ntype ShippingAddress = NonNullable<NonNullable<ShippingAddresses>[number]>;\ntype AvailableShippingMethods = ShippingAddress['available_shipping_methods'];\ntype AvailableShippingMethod = NonNullable<AvailableShippingMethods>[number];\ntype SelectedShippingMethod = ShippingAddress['selected_shipping_method'];\n\ntype FilteredShippingMethod = Omit<\n  NonNullable<AvailableShippingMethod>,\n  'method_code' | 'method_title' | 'amount'\n> & {\n  method_code: string;\n  method_title: string;\n  amount: {\n    value: number;\n    currency: string;\n  };\n};\n\nconst byPrice = (a: ShippingMethod, b: ShippingMethod) =>\n  a.amount.value - b.amount.value;\n\nconst isValid = (method: AvailableShippingMethod | SelectedShippingMethod) => {\n  if (!method) return false;\n  if (!method.method_code || !method.method_title) return false;\n  if (isNullish(method.amount.value) || !method.amount.currency) return false;\n  return true;\n};\n\nconst buildShippingMethod = (data: FilteredShippingMethod): ShippingMethod => {\n  return {\n    amount: {\n      value: data.amount.value,\n      currency: data.amount.currency,\n    },\n    title: data.method_title,\n    code: data.method_code,\n    carrier: {\n      code: data.carrier_code,\n      title: data.carrier_title,\n    },\n    value: `${data.carrier_code} - ${data.method_code}`,\n  };\n};\n\nexport const transformSelectedShippingMethod = (\n  data: SelectedShippingMethod\n): ShippingMethod | undefined => {\n  if (!isValid(data)) return;\n  return buildShippingMethod(data as FilteredShippingMethod);\n};\n\nexport const transformAvailableShippingMethod = (\n  data: AvailableShippingMethod\n): ShippingMethod | undefined => {\n  if (!isValid(data)) return;\n  return buildShippingMethod(data as FilteredShippingMethod);\n};\n\nexport const transformShippingMethods = (\n  data: AvailableShippingMethods\n): ShippingMethod[] | undefined => {\n  if (!data) return;\n\n  return data\n    .filter(isValid)\n    .map((method) => buildShippingMethod(method as FilteredShippingMethod))\n    .sort(byPrice);\n};\n","import { Cart } from '@/checkout/data/models';\nimport { signal } from '@preact/signals';\n\nexport const cartSignal = signal<{\n  pending: boolean;\n  data?: Cart | null;\n}>({ pending: false, data: undefined });\n","import { signal } from '@preact/signals';\nimport { ShippingMethod } from '@/checkout/data/models';\n\nexport const estimateShippingMethodsSignal = signal<{\n  pending: boolean;\n  data?: ShippingMethod[];\n}>({ pending: false, data: undefined });\n","import { AddressFormType } from '@/checkout/data/models';\nimport { Region as RegionModel } from '@/checkout/data/models/region';\nimport { signal } from '@preact/signals';\n\nexport const regionsSignal = signal<{\n  addressType?: AddressFormType;\n  country?: string;\n  selectedRegion?: string;\n  selectedRegionId?: string;\n  pending: boolean;\n  data?: RegionModel[];\n}>({ pending: false, data: undefined });\n","const requestsQueue: (() => Promise<any>)[] = [];\n\nexport function enqueueRequest<T>(requestFn: () => Promise<T>): Promise<T> {\n  return new Promise((resolve, reject) => {\n    requestsQueue.push(requestFn);\n\n    const waitForTurnAndSendRequest = () => {\n      if (requestsQueue[0] === requestFn) {\n        requestFn()\n          .then(resolve)\n          .catch(reject)\n          .finally(() => requestsQueue.shift());\n      } else {\n        setTimeout(waitForTurnAndSendRequest, 100);\n      }\n    };\n\n    waitForTurnAndSendRequest();\n  });\n}\n","import { FetchQueryError } from '@adobe/fetch-graphql';\n\ntype ErrorPath = (string | number)[];\n\nexport type ErrorWithPath = FetchQueryError[number] & {\n  path?: ErrorPath;\n};\n\nconst controlledErrorProps: string[] = ['sender_email', 'recipient_email'];\n\n/**\n * Filters out errors with known paths from a list of errors generated by a GraphQL query.\n *\n * Known issue: The query does not differentiate between physical and virtual gift cards, leading\n * to errors for physical ones as they don't have 'sender_email' and 'recipient_email' properties.\n *\n * @param {ErrorWithPath[]} errors - Array of errors to be filtered.\n * @return {ErrorWithPath[]} Uncontrolled (unexpected) errors not matching predefined paths.\n */\n\nexport function filterControlledErrors(errors: ErrorWithPath[]) {\n  return errors.filter(\n    (error) =>\n      !error.path ||\n      !controlledErrorProps.some((controlledErrorProp) => {\n        return error.path?.at(-1) === controlledErrorProp;\n      })\n  );\n}\n","import { FetchError, fetchGraphQl } from '@/checkout/api';\nimport { handleNetworkError } from '@/checkout/lib/network-error';\nimport {\n  cartSignal,\n  regionsSignal,\n  estimateShippingMethodsSignal,\n} from '@/checkout/signals';\n\nimport { FetchOptions, FetchQueryError } from '@adobe/fetch-graphql';\nimport { enqueueRequest } from '@/checkout/api/utils/enqueueRequest';\nimport { filterControlledErrors } from '@/checkout/api/utils/filterControlledErrors';\n\nconst signalTypes = {\n  cart: cartSignal,\n  regions: regionsSignal,\n  estimateShippingMethods: estimateShippingMethodsSignal,\n};\n\ntype SignalTypesType = typeof signalTypes;\ntype SignalTypesKeys = keyof SignalTypesType;\ntype SignalDataMap = {\n  [K in SignalTypesKeys]: SignalTypesType[K]['value']['data'];\n};\ntype DispatchApiCallParams<T extends SignalTypesKeys> = {\n  type: 'query' | 'mutation';\n  query: string;\n  options?: FetchOptions;\n  path: string;\n  signalType: T;\n  transformer?: (data: any) => SignalDataMap[T];\n};\n\nexport function getValueAtPath(obj: any, path: string) {\n  return path\n    .split('.')\n    .reduce(\n      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : undefined),\n      obj\n    );\n}\n\nconst latestCall: Record<SignalTypesKeys, Symbol | null> = {\n  cart: null,\n  regions: null,\n  estimateShippingMethods: null,\n};\n\nasync function dispatchApiCall<T extends SignalTypesKeys>(\n  params: DispatchApiCallParams<T>\n): Promise<SignalDataMap[T]> {\n  const { query, options, path, signalType, type, transformer } = params;\n  const signal = signalTypes[signalType];\n  const currentCall = Symbol();\n\n  latestCall[signalType] = currentCall;\n\n  signal.value = { ...signal.value, pending: true };\n\n  try {\n    const { data, errors } = await (type === 'mutation'\n      ? enqueueRequest(() =>\n          fetchGraphQl(query, options).catch(handleNetworkError)\n        )\n      : fetchGraphQl(query, {\n          method: 'GET',\n          cache: 'no-cache',\n          ...options,\n        }).catch(handleNetworkError));\n\n    if (errors) {\n      const uncontrolledErrors = filterControlledErrors(errors);\n\n      if (uncontrolledErrors.length > 0) {\n        throw new FetchError(uncontrolledErrors as FetchQueryError);\n      }\n    }\n\n    let result = getValueAtPath(data, path);\n    if (result === undefined) throw new Error(`No data found at path: ${path}`);\n    if (transformer) result = transformer(result);\n\n    signal.value = { ...signal.value, data: result };\n\n    // to avoid flickering of the pending state when there are multiple sequential calls\n    setTimeout(() => {\n      signal.value = {\n        ...signal.value,\n        pending:\n          latestCall[signalType] === currentCall ? false : signal.value.pending,\n      };\n    }, 0);\n\n    return result;\n  } catch (error: any) {\n    if (error.name === 'AbortError') return;\n    signal.value = { ...signal.value, pending: false };\n    throw error;\n  }\n}\n\nexport { dispatchApiCall };\n"],"names":["FetchError","Error","constructor","reasons","map","e","message","join","name","InvalidArgument","UnexpectedError","MissingCart","MissingEmail","MissingPaymentMethod","MissingBillingAddress","MissingCountry","byPrice","a","b","amount","value","isValid","method","method_code","method_title","isNullish","currency","buildShippingMethod","data","title","code","carrier","carrier_code","carrier_title","transformSelectedShippingMethod","transformShippingMethods","filter","sort","cartSignal","signal","pending","undefined","estimateShippingMethodsSignal","regionsSignal","requestsQueue","enqueueRequest","requestFn","Promise","resolve","reject","push","waitForTurnAndSendRequest","then","catch","finally","shift","setTimeout","controlledErrorProps","filterControlledErrors","errors","error","path","some","controlledErrorProp","at","signalTypes","cart","regions","estimateShippingMethods","getValueAtPath","obj","split","reduce","acc","part","latestCall","dispatchApiCall","params","query","options","signalType","type","transformer","currentCall","Symbol","fetchGraphQl","handleNetworkError","cache","uncontrolledErrors","length","result"],"mappings":"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"}